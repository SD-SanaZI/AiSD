#include <stdio.h>
#include <stdlib.h>

struct elem				//Структура элемента стека
{
	struct elem* head;
	struct elem* tail;
	char sim;
};

int IsEmpty(struct elem* stack)		//Функция проверяющая стек на пустоту
{
	if(stack==NULL)
		return 0;
	return 1;
}

int push(struct elem** stack,char ch)		//Функция добавляющая элемент в конец стека
{
        if(IsEmpty(*stack)==0)			//Если стек пуст,создаем структуру,заполняем ее,запихиваем в стек
        {
		struct elem *a=(struct elem*)calloc(1,sizeof(struct elem));
		*stack=a;
                a->head=NULL;
		a->tail=NULL;
                a->sim=ch;
	}
	else					//В обратном случае доходим до конца стека и новую заполненную структуру запихиваем в конец стека
	{
		struct elem* el=*stack;
		struct elem *a=(struct elem*)calloc(1,sizeof(struct elem));
		while(el->tail!=NULL)
	                el=el->tail;
		el->tail=a;
		a->head=el;
		a->tail=NULL;
		a->sim=ch;
	}
}

char  top(struct elem** stack)			//Функция возвражающая символ последнего элемента стека
{
	if(IsEmpty(*stack)==0)			//Если стек пустой позвращаем символ $
		return '$';
	struct elem* el=*stack;
	while(el->tail!=NULL)
		el=el->tail;
	return el->sim;
}

int  pop(struct elem** stack)			//функция удаляющая последний элемент стека
{
        if(IsEmpty(*stack)==0)
                return 1;
        struct elem* el=*stack;
        while(el->tail!=NULL)			//доходим до конца стека
                el=el->tail;
	if(el->head!=NULL)			//если в стеке более 1 елемента
	{
		el->head->tail=NULL;
		free(el);
	}
	else					//если элемент последний стек обнуляется
	{
		free(el);
		*stack=NULL;
	}
	return 0;
}

int destroy(struct elem** stack)		//Функция высвобождающая всю память стека
{
        if(IsEmpty(*stack)==0)
                return 0;
        struct elem* el=*stack;
        while(el->tail!=NULL)
                el=el->tail;
	while(el->head!=NULL)
	{
		el=el->head;
		free(el->tail);
	}
	free(el);
}

int are_correct(char* str,char** simbol)	//Функция, проверяющая на корректность введенную формулу
{
	struct elem* stack=NULL;
	*simbol=str;				//simbol служит счетчиком пройденной строки
	int chac=0;				//Симол для проверок
	while(**simbol!='\0')			//Пока не пройдем строку
	{
		chac=1;				//Нужен для проверки , попал ли simbol хоть в один if
		if(**simbol=='(' || **simbol=='[' || **simbol=='{')		//Если открывающиеся скобки
		{
			printf("Найдена открывающаяся скобка %c.За ней должна следовать переменная<x;y;z> или открывающаяся скобка <(;{;[>.\n",**simbol);
			if(*(*simbol+1)=='(' || *(*simbol+1)=='x' || *(*simbol+1)=='y' || *(*simbol+1)=='z' || *(*simbol+1)=='{' || *(*simbol+1)=='[')//проверка на корректность следующего символа
			{
				push(&stack,**simbol);
				printf("	Следующий символ корректен.\n");
			}
			else
			{
	                        printf("        Следующий символ не корректен.\n	Программа закрывается.\n	Выводится результат.\n");
				destroy(&stack);
				return 1;
			}
			chac=0;
		}
		if(**simbol==')')						//Если закрывающаяся скобка
		{
			printf("Найдена закрывающаяся скобка %c.За ней должен следовать знак<+;-> или закрывающаяся скобка <);};]>.\n",**simbol);
			printf("Так же необходимо,чтобы предыдущая скобка была (.\n");
			if((top(&stack)=='(') &&(*(*simbol+1)==')' || *(*simbol+1)=='}' || *(*simbol+1)==']' || *(*simbol+1)=='+' || *(*simbol+1)=='-' || *(*simbol+1)=='\0'))//проверка на корректность следующего символа
			{
				pop(&stack);
				printf("	Следующий символ корректен.\n        Предыдущая скобка корректна.\n");
			}
			else
			{
	                        printf("        Следующий символ или предыдущая скобка не корректен.\n	Программа закрывается.\n	Выводится результат.\n");
                                destroy(&stack);
                                return 2;
			}
			chac=0;
		}
                if(**simbol=='}')						//Если закрывающаяся скобка
                {
			printf("Найдена закрывающаяся скобка %c.За ней должен следовать знак<+;-> или закрывающаяся скобка <);};]>.\n",**simbol);
			printf("Так же необходимо,чтобы предыдущая скобка была {.\n");
                        if((top(&stack)=='{') &&(*(*simbol+1)==')' || *(*simbol+1)=='}' || *(*simbol+1)==']' || *(*simbol+1)=='+' || *(*simbol+1)=='-' || *(*simbol+1)=='\0'))//проверка на корректность следующего символа
			{
                                pop(&stack);
				printf("	Следующий символ корректен.\n        Предыдущая скобка корректна.\n");
			}
                        else
                        {
	                        printf("        Следующий символ или предыдущая скобка не корректен.\n	Программа закрывается.\n	Выводится результат.\n");
                                destroy(&stack);
                                return 3;
                        }
			chac=0;
                }
                if(**simbol==']')						//Если закрывающаяся скобка
                {
			printf("Найдена закрывающаяся скобка %c.За ней должен следовать знак<+;-> или закрывающаяся скобка <];);}>.\n",**simbol);
			printf("Так же необходимо,чтобы предыдущая скобка была [.\n");
                        if(top(&stack)=='[' &&(*(*simbol+1)==')' || *(*simbol+1)=='}' || *(*simbol+1)==']' || *(*simbol+1)=='+' || *(*simbol+1)=='-' || *(*simbol+1)=='\0'))//проверка на корректность следующего символа
			{
				printf("	Следующий символ корректен.\n        Предыдущая скобка корректна.\n");
                                pop(&stack);
			}
                        else
                        {
	                        printf("        Следующий символ или предыдущая скобка не корректен.\n	Программа закрывается.\n	Выводится результат.\n");
                                destroy(&stack);
                                return 4;
                        }
			chac=0;
                }
                if(**simbol=='+' || **simbol=='-')				//Если знак
		{
			printf("Найден знак %c.За ней должна следовать переменная<x;y;z> или открывающаяся скобка <(;{;[>.\n",**simbol);
			if(*(*simbol+1)=='(' || *(*simbol+1)=='x' || *(*simbol+1)=='y' || *(*simbol+1)=='z' || *(*simbol+1)=='{' || *(*simbol+1)=='[')//проверка на корректность следующего символа
			{
				printf("	Следующий символ корректен.\n");
				chac=0;
			}
			else
			{
	                        printf("        Следующий символ не корректен.\n	Программа закрывается.\n	Выводится результат.\n");
				destroy(&stack);
				return 5;
			}
		}
                if(**simbol=='x' || **simbol=='y' || **simbol=='z')		//Если переменная
		{
			printf("Найдена переменная %c.За ней должен следовать знак<+;-> или закрывающаяся скобка <);};]>.\n",**simbol);
                        if(*(*simbol+1)==')' || *(*simbol+1)==']' || *(*simbol+1)=='}' || *(*simbol+1)=='+' || *(*simbol+1)=='-' || *(*simbol+1)=='\0')//проверка на корректность следующего символа
			{
				printf("	Следующий символ корректен.\n");
                                chac=0;
			}
		        else
			{
	                        printf("        Следующий символ не корректен.\n	Программа закрывается.\n	Выводится результат.\n");
				destroy(&stack);
                                return 6;
			}
		}
		if(chac!=0)							//Если не вошел ни в один if
		{
			printf("Найден неопределенный в задании символ %c.        Программа закрывается.\n        Выводится результат.\n",**simbol);
			return 7;
		}
		*simbol=*simbol+1;
	}
	printf("Программа закончила обработку строки.\n");
	if(IsEmpty(stack)!=0)							//если остались не закрытые скобки
	{
		printf("Не все открытые скобки были закрыты.\n        Программа закрывается.\n        Выводится результат.\n");
                destroy(&stack);
		return 8;
	}
        printf("        Программа закрывается.\n        Выводится результат.\n");
	return 0;
}

int main()								//Основная функция
{
	printf("Введите 1 , если хотите считать строчку из файла, в обратном случае введите любое другое число.\n");
	int key;							//Переменная является ключем для метода считывания, а после используется как счетчик
	scanf("%d",&key);
	char str[1000];							//Строка для считывания и обработки
	str[0]='1';
        char* stop=str;							//Указатель для избавления от \n, и проверки на считывания строки из файла
	while(str[0]!='\n')
		scanf("%c",&str[0]);
        if(key==1)							//Если требуется считывание из файла
        {
                FILE* file;
	        key=0;
                printf("Введите путь к файлу от текущей дирректории.\n");
		fgets(str,1000,stdin);
		stop=str;
                while(*stop!='\n' && key<1000)                                          //Избавление от \n
                {
                        stop++;
                        key++;
                }
                *stop='\0';
		file = fopen (str,"r");					//Открытие файла
		if (file == NULL)					//Если файл не открыт
		{
			printf("Файл %s не был открыт.",str);
			return -1;
		}
		stop = fgets (str,sizeof(str),file);			//Считывание строки из файла
		if(stop==NULL)						//Если строка не считалась
		{
			printf("Строка файла не считалась.");
			return -1;
		}
		if(fclose(file)==EOF)					//Если файл не закрыт
		{
			printf("Файл не смог закрыться");
			return -1;
		}
        }
	else								//Если строка вводится вручную
	{
		printf("Введите выражение.\n\n<формула> ::= <терм>|<терм>+<формула> | <терм>-<формула>\n<терм> ::= <имя> | (<формулa>) | [<формула>] | {<формула>}\n<имя> ::= x | y | z\n\n");
		printf("В выражении не должно быть более 100 символов, иначе функция не будет считать выражением первые 1000 символов.\n\n");
		fgets(str,1000,stdin);						//Считывание
	}
	stop=str;
	key=0;
	while(*stop!='\n' && key<1000)						//Избавление от \n
	{
		stop++;
		key++;
	}
	*stop='\0';
	int result=are_correct(str,&stop);				//Проверка строки
	if(result==0)							//Если проверка пройдена успешно
		printf("\nВыражение является формулой.\n");
	else								//Если не успешно
	{
		if(str[0]!='(' && str[0]!='[' && str[0]!='{' && str[0]!='x' && str[0]!='y' && str[0]!='z')			//Если ошибка на первом же символе
			printf("\nВыражение не является формулой.\nОшибка на %d-ом символе.\nНичего не введено верно.\n",1);
		else														//В остальных случаях
		{
                        printf("\nВыражение не является формулой.\nОшибка на %d-ом символе.\n",stop-str+2);
			str[stop-str+1]='\0';				//Обрезка строки для вывода во куда строка была верна
			printf("Верно введено: \n%s\n",str);		//Вывод строки
		}
	}
}
